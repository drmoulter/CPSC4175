Devon Moulter  
Homework 2  

1. The first step in creating a piece of software is analyzing the
client's situation. This includes not just listening to what the
client wants but also getting details about the client's current
work enviroment and using those details to determine how to solve
the client's actual problem.

2. Discovering what a client needs requires the client to be
a good communicator and the software engineer to be able
to analyse the client's situation; this entails constant
communication between the client and software engineer
Discovering what exactly the software must do requires more
detailed knowledge about the requirements domain--such as
commonly used formulas and distinct differences between
similar terms. Though this still requires communication,
it also requires good research on the developer's part.

3. Software engineers can be seen as specialists due to needing
to learn about a variety of topics. Creating a program for a
specific application domain may require being famaliar with
that domain's terminology. For example, creating software
for a space exploration program would require the software
engineer to research astrological terms, and developing
well-functioning software for a construction company would
require knowledge of distinct differences between various
construction materials.

4. The first technique the book presents is interviewing
the client, but as the book notes, this may prove
ineffective by itself because clients may not understand
what they need or how to explain their requirements to
a software engineer. Another technique the book mentions
is sending a questionaire to relevent members of the
client organization. This second method, however, requires
preplanning, so clients may not be able to ask questions
as actively as during an interview. One last method the
book explains is watching users in the client's workplace.
This final method can be the most useful for learning
what the client truly needs, but can be very time consuming
and can viewed as an invasion of privacy by some workers.

5. As noted in the first chapter, software can take a long
time to design and develop. During this time, many factors
involving the client and requirements domain can change; a
change in the client's attitude or desires, new discoveries
in the domain, the introduction of new software tools, and
new problems in the client's workplace are all example of
changes that may alter software requirements. Thus,
requirements must be dynamic as opposed to static.

6. Functional requirements dictate what actions the main
product itself must perform. For example, a calculator
must be able to perform basic math operations, accept
input for performing said operations, and output correct
answers or appropriate error messages. In other words,
functional requirements mostly deal with I/O and
internal calculations. Nonfunctional requirements
specify properties of the product--such as response time,
platform requirements, and reliability. When functional
and nonfunctional requirements are explained in this way,
it becomes clear that functional requirements are concerned
with the functions of the product's code while nonfunctional
requirements deal more with specifications external to
the product's code.

7. Top-down analysis is a method of design in which the
system is first viewed as a whole before being contunally
broken down into smaller and smaller components until the
smallest possible components are designed. The case study
in chapter 11 seems to focus more on the actions and
interactions of actors in a system, mapping out a use-case
diagram based on of the MSG Foundation and its processes.

8. One reason prototyping could be deemed harmful is
because some may consider prototypes a waste of time
and resources. Some prototypes, especially rapid
prototypes, do not use the same programming language
as the intended final product, so the code of the
prototype will likely need to be rewritten to fit
the syntax of another language. In addition, if a
developer is not careful, problems in the prototype--
such as typos and code that causes crashes--could
be carried over into the main product.

9. As I explained in question 5, requirements are dynamic.
As such, I would say Team Two (the team that frequently
chnages their requirements specifications) are likely
doing the better job because they are constantly
perceiving and analysing factors that could change
the needs of their product. Team One, on the other
hand, may end up with a more outdated product due to not
considering such changes as much as Team Two.

10. Before one can obtain something they need, they must
first know what they need. For example, if someone
requires a particular diet to stay healty but does
not know about this diet, that person will not be
able to eat the foods required to stay healthy. The
same principle applies to software engineering. In order
to create the software that a client needs, the software
engineer must first analyze the needs of the client.
Without a requirements analysis, the software engineer
will not know what to include in the final product.
For example, if the client needs a product with improved
security system but the software engineer is not aware of
this need, the product may lack the necessary
security features.