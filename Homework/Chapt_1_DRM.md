Devon Moulter  
Homework 1  

1. According to the book, the four main concerns
in regards to the software crisis are disputes
that end in lawsuits, completed software not
meeting clients' expectations, products being
completed past deadlines, and finished products
being unusable due to severe faults.

2. Based on what I've read from the book and
what we've gone over in class, I would say
the software life cycle is a more overarching
process than the software development cycle.
The software lif cycle refers to all the
phases of a software's lif span, from gathering
the program's requirements to retiring the
program from use. The development cycle
can cover different step depending on the
definition. Older definitions dictate that
development occurs strictly before the final
product is delivered; any postdelivery changes
would be referred to as maintenance under
this definition. More recent definitions
generally include postdelivery maintenance
would be included in the development cycle;
thus, under modern definitions, the
development cycle would include all steps
of a product's lifespan up to (but not
including) retirement.

3. An example of perfective maintenance would
be the UI in the Persona games; in Persona 3
and Persona 4, players would have to scroll
through each of the options in the battle
menu by moving a cursor up and down. In
Persona 5, however, each of the major menu
options is mapped to a different button on the
controller, allowing players to more quickly
select the options they want. In this case,
a change was made to make gameplay more
convenient for the player. An example of
corrective maintenance would be how Ray-Man
Legends's release date was pushed back;
originally, Ray-Man Legends was supposed
to be released exclusively on the Wii U,
but the game's release was delayed so that
it could also be developed for other home
consoles. This change was likely made by the
game's developers in response to the Wii U's
poor sales.

4. Hardware has the misfortune of existing
in the physical world. No matter how much
one tries to fix hardware, it will evantually
become unusable; metal rusts, plastics
break apart, and some technology simply
becomes obselete. Software, however, is not
bound but these restrictions. As long as a
copy of piece of code still exists, it can
be recovered, patched, and updated as
necessary. In addition, while hardware
requires physical materials to repair or
upgrade, software merely requires time
to perform necessry maintenance. Thus, with
just a little time and effort, software can
be constantly corrected and adapted to
remain up-to-date.

5. Because the most costly yet common faults
occur during and after implementation, errors
are often quite costly to correct. Though it
would be ideal to correct mistakes earlier
on in development, the fact that most errors
are caught during implementation shows that
finding problems can be difficult.

6. There are likely no clear-cut planning,
testing, and documentation phases because
situations can quickly change in the world
of software development; new technologies
can be discovered, new errors in the
product can be found, and clients' demands
can change. Thus, plans will need to be
changed, documentation needs to be updated
as necessary, and the product will need
to tested and retested as the product is
changed. Even after the product is delivered
to the client, additional maintenance
(and thus additional planning, testing, and
documentation) may be required to correct errors
that were missed and update the software to keep
up with new technologies.

7. Structured programming helped lay the
foundation for object-oriented programming.
Before structured programming, it was up
to a programmer to orgaize their code. This
code result in jumbled messes that made it
difficult for the programmer to correct
mistakes in his/her code and for others
to reuse that code. Structured programming
introduced principles that encouraged
developers to plan out their products
and break up products into manageable chunks.
Object oriented programming added new principles
upon the structured paradigm to help further
organize development, much like how compoments
of pre-existing products are often reused
in new products.

8. When it comes to software design, it more
importatnt to communicate with the people
who will be using the product. While
listening to the client's request is important,
users may provide important clues on how to
improve the product's UI and give other ideas
to improve users' experiences.

9. I think the best way for me to learn
about my profession is simply perform
tasks related to my profession. In this
case, that would mean designing and
implmenting software to solve even simple
problems. Even recognizing a problem,
creating a plan to solve that problem,
and writing pseudocode can be good practice
for software engineering.

10. Eric Steven Raymond's "The Cathedral
and the Bazaar" helps shine a new
perspective on software development.
In the article, he explains how keeping
code open-sourced and encouraging others
to help in its development can drastically
reduce time devoted to debugging, often
using the success of Linux as an example.
According to Raymond's analysis of Linux
and his own personal experiences,
creating programs with the aid of many
is more efficient than creating them
in a closed enviroment because of the
many different ways unique individuals
can tackle problems; as Raymond notes,
what may seem like a complicated problem
to one person may be an easy-to-fix
bug to another. In addition, Raymond
asserts that problems are more easily
discovered and resolved due to the
eagerness of contributers; in the
"On Management and the Maginot Line"
section, Raymond argues that people
who willingly choose to assist in a
project are more likely to give their
best efforts to fix problems than
"buildings full of people who rather
be doing something else."  In addition
to his many persuasive arguments for
open-source projects, Raymond also
provides many numbered principles
and observations that can serve as
excellent advice for any programmer.
Overall, Eric Raymond's "The Cathedral
and the Bazaar" is a worthwhile read for
any aspiring software engineer.
